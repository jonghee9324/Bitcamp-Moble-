@ 접근제어자
protected private기능이 자손클래스까지 허용되는 것
(즉, private을 사용하면 상속받은 클래스는 사용할 수 없지만 protected 를 사용하면 상속받은 클래스는 사용가능. 
상속받지 않은 클래스는 사용할 수 없음)

@final
final이 붙은 클래스는 상속할 수 없음, 메소드는 오버라이딩 불가
인스턴스 변수의 기본값으로 초기화 된 경우, 생성자의 한에서 1회 값을 설정할 수 있음



@abstract
추상클래스는 추상메소드와 일반 메소드를 갖음
메소드 : 선언부만 있고 구현부가 없음 ( abstract void move(); )
클래스 : 클래스 내에 추상메서드가 선언됐음을 의미
abstract메서드를 가지고 있으면 클래스는 abstract라고 선언되어야함, 상속에서 사용됨
조상은 선언만하고 자손이 추상클래스, 메소드를 정의함

추상클래스를 상속받은 자식클래스는 조상클래스의 추상메소드를 반드시 구현해야함. 안하면 에러

@ @overide // 다음 메소드는 오버라이드 라는것을 표시해줌

@접근제어자
default // 아무것도 적히지않음 같은 패키지 내에서만 접근가능 
public // 어디서나 접근가능
private을 생성자에 작성하면 인스턴스를 만들 수 없음, 이 때 인스턴스를 하나만 만들기위한 싱글톤 패턴에 사용된다.


@싱글톤패턴
인스턴스를 하나만 만들고 싶어서 사용, 생성자를 private로 선언함, 인스턴스 생성시 에러.
인스턴스를 만드는방법은 메소드를 통해 만들어야함.
인스턴스를 안 만들고 메소드를 통해 인스턴스를 만들기 때문에 getInstance(인스턴스 생성 메소드)는 항상 static이여야함
싱글톤 패턴으로 작성할 클래스 내부엔 자기 자신 인스턴스를 갖음, 이 때 이 변수를 static으로 선언함
자신의 인스턴스를 만들기위한 메소드 또한 static으로 선언.
static으로 선언되었기 때문에 메인에서 메소드를 통해 여러개의 인스턴스를 만들어도, 그 여러개의 인스턴스들은 공통의 인스턴스를 사용한다.
ex )
mc1 = getInstance()
mc2 = getInstance()
mc3 = getInstance()
mc1,2,3 여러개의 인스턴스는 Myclass의 인스턴스는 같다.

@인터페이스
추상메소드와 상수로만 이루어진 집합

@변수 초기화
참조형 변수의 초기값은 null

@다형성
조타참(조상 타입의 참조 변수로),
자타객(자손 타입의 객체를 다룰 수 있는 성질)
조상 클래스의 변수에 자손 타입의 객체를 넣는것
ex)
조상 클래스 tv, 자손 클래스 cptv
tv t = new cptv() // 로 사용
단, 조상타입으로 생기기 때문에 자손클래스만 갖고 있는 인스턴스 변수를 사용할 수 없다.
tv - ch만 있고 ,cptv - n이 있다고 가정 시 t.n은 사용불가 사용하기 위해선 자식 클래스 형태로 타입캐스팅해서 객체를 만든다
cptv cc = (cptv) t
이때 cc.n 사용가능


@상속
상속 받을 때 조상클래스가 기본생성자 외에 매개변수를 받는 생성자를 구현하면,자식 클래스 또한 똑같이 매개변수를 받는 
생성자를 구현해야함

@에러
런타임에러 // 실행은 되다가 에러가 나면 도중에 뻗음
컴파일에러 // 컴파일 시 에러가 나서 실행이 안됨