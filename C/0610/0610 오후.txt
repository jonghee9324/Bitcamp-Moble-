@배열
배열은 같은 자료형을 가지고 있는 포인터
4차원 이상 배열 사용하지 말것, 3차원도 데이터 관리가 어렵기 때문에 사용하지 말 것(엑셀도 2차원)
같은 자료형의 주소를 연결시킨 것, 그래서 자료형과, 사용할 사이즈를 지정해야함.
단점 : 같은 자료형만 사용해야한다.


@포인터
포인터 : 변수의 주소만 넣으세요, 주소를 통해 값을 가지고 오는 연산. ( * )
포인터변수 : 주소( 주소 == 포인터변수)
사용이유 : 하나의 변수를 모두 공유해서 쓰고싶기 때문. (call by reference)

포인터 tip )
포인터는 어떻게 선언하든지 (자료형*) 로 생각할 것
int* = 인트형 포인터 자료형, 데이터 사이즈는 인트형 포인터 사이즈
포인터 변수 안에 저장된 주소의 값을 불러오는 * 은 연산이다.

포인터 변수 안에 상수를 넣으면 *(포인터변수) 연산 시 상수를 주소로 판단하고 연산을 실행,
연산을 실행할 수 없어 에러가 발생한다.
ex) int* p =1 이라 가정
1을 주소로 생각한다. 그래서 p를 출력하면 1이 나온다.
*p를 사용하면 p안의 주소 1로가서 값을가져오려고 찾는다. 하지만 1은 상수기 때문에 연산이 실행이 되지 않는다.
*p의 *는 연산을 말하고, p변수 안의 값을 주소로 생각해 그 주소로 타고들어가 값을 가져오는 연산이다.

다중 포인터의 경우 다중의 정도만큼 *을 써줘야함( 다중은 이중포인터부터 다중이라함)
즉, 이중 포인터의 경우 변수 앞에 **을 붙여서 선언. 

*&c == c의 값 ( *와&를 같이쓰면 상쇄됨)

int arr[10] ={1,2,3,4,5}
int* a = arr;
printf("%d", a)	// 5000 이라 가정 (a == &a[0] , *a == *&a[0], 출력값은 둘 다 1)
printf("%d", a+1) // 5004 출력, 주소값은 자료형의 사이즈만큼 차이가 난다. ( a+1 == &a[1] , *(a+1) == *&a[1], 출력값 : 2)

long은 비트에 따라 다르게 출력됨 64(x64)비트는 8바이트, 32(x86)비트는 4바이트
따라서 위 예제를 int가 아닌 long으로 바꿀 시, 주소는 32비트에서는 5000,5004/ 64비트는 5000,5008이 나온다.
(비주얼 c에서 비트는 로컬윈도우디버거 버튼 옆 x86이라 적힌 콤보박스를 눌러 변경 가능)

*(a+1) 랑 (*a+1) 는 다름, 전자는 a의 주소에 1을 더한 것이고, 후자는 a의 안의 주소가 가르키는 값에 1을 더한 것
int* arr[10] 은 이중포인터. (배열은 포인터이기 때문)

이중포인터는 주소의 주소일 경우 사용하지만 주소만 사용해도 사용가능하다.
ex) 
int a = 10;
int **b = &a (사용가능)



@구조체

