@헤더파일
함수원형(함수 프로토타입)만 모아둔 파일

@함수
같은 이름의 함수는 유일해야한다. 즉, 오버로딩이 되지 않는다.
함수 반환 타입에 따라 반드시 리턴 해야한다. 
(void는 return; 해야함 하지만 컴파일러가 해주기 때문에 생략가능)

@재귀함수
자기자신을 호출하는 함수, 탈출조건 필요
재귀함수로 바로 코딩하지말고, 반복문으로 먼저 만들고 그 뒤에 재귀함수로 반복문 내용을 바꿔준다.
재귀함수는 메모리에 쌓여서 잘 사용되지 않는다.

@배열
주소(자료형), 포인터
주소이다. 그리고 자료형이 정해져있고, 자료의 사이즈가 정해진 데이터
자료의 size는 자료형(메모리크기) / 자료의 사이즈가 1byte면 주소는 1byte씩 건너뛴다.4byte면 4씩
int arr[10] (int는 자료의 사이즈를 알기위해, [10]은 얼마나 저장공간을 잡을지 알기위해 작성)
배열은 반드시 상수가 들어가야함.

문자열은 입력할 문자보다 1개씩 더 많게 해야함
그래서 문자열은 char str[] = "입력내용"; 이렇게 사용할 것 (왜 ? 문자열에 뭐가 들어갈지모르기 때문)
그래서 배열보단 포인터를 사용함, 배열사이즈로 정해서 사용하지 말것
사용하고 싶으면 배열의 사이즈를 정하지 않고 사용할 것
문자열 출력시 ("%s", 배열이름), 문자열은 항상 맨 마지막에 널 값이 들어감, 문장의 끝을 표현하기 위함
%s 는 주소를 받기 때문에 주소로 들어가서 일단 다찍고 널값이 들어가면 그만 찍는다.

scanf로 문자열을 입력받을 때 ("%s , 배열이름) >> 배열이 주소이기 때문에 &는 사용하지 않아도됨

@포인터
포인터로 선언시 상수는 들어갈 수 없음
반드시 &로 작성해야함
원래는 상수는 포인터로 되지 않는게 정상 되는게 이상한것
ex ) int *a = 1 는 안되는것이 정상