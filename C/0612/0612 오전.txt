@void 포인터
주소만 갖을 수 있는 자료

@배열, 구조체, 클래스 비교
배열 : 같은 자료형에 크기 고정
구조체 : 다른 자료형 들어갈 수 있음, 초기화 x, 함수 x
클래스 : 변수 + 메소드 집합

@구조체
구조체는 struct 구조체명 까지가 자료형이다.

@동적할당
구조체 배열을 선언하고 구조체 배열안에 캐릭터형 포인터 변수를 선언하고
scanf로 구조체 원소에 직접 이름을 입력받아 값을 넣어준다고 가정하면 가장 마지막으로 받은 이름으로 다찍힌다.
이 상황은 (call by reference) 이 때 필요한 것이 동적할당
for(){
char *name[50]
} 동적할당아님, 같은 결과가 나옴, c이기 때문에 이미 메모리에 한 번 올라가 같은 주소이다. 새로 만드는 것이 아님

따라서 (사용할자료형)malloc(크기) 로 동적할당 받는다.( 크기는 사이즈계산을 입력하면 되는데 계산이 귀찮아 sizeof(사용할자료형) 로 사용
결론적으로 (사용할자료형)malloc(sizeof(사용할자료형))으로 사용한다.

call by reference에서 주소가 같으면 값이 같아져서 주소를 새로 할당해 져야하기 때문에 
reference를 value처럼 사용하고 싶기 때문.

free(메모리 반납할 변수명)를 통해 동적할당 받은 메모리를 반환할 수 있따.

모든데이터는 메모리 스택에 들어간다. 하지만 malloc을 사용하면 스택에 들어가지 않고, 큐 구조의 heap(힙)메모리에 들어간다.
힙메모리는 동적메모리이다. 
반드시 동적할당을 하면 free를 해줘야한다. 하지만 free위치를 잘 생각해야한다.

@typedef
typedef를 통해 변수명도 바꿔서 사용가능.
typedef int INT로 선언시 int를 INT로 사용할 수 있다.
typedef char* String으로 선언시 String 으로 char* 대신 String사용가능
하지만 사용하지 말것

@enum
열거형 자료형
사용법 : enum List{NAME, ARR, KOR}
넣은 자료는 알아서 1씩 증가한다.
자동으로 NAME부터 0이 들어간다. ARR =1, KOR=2
강제로 ARR =8 로 작성 시 NAME = 0, ARR = 8,  KOR = 9가 된다.

@전처리기
전처리기는 컴파일러에 의해 처리되는 것은 아니다.
#define로 선언한 것은 매크로라고 한다.
#if ~ #endif를 사용해서 테스트 시킬 수 있다.

@파일 입출력
접근모드 r, w, a r+, w+, a+
입출력 모드 : t(텍스트), b(이진모드)
파일개방모드 : 접근모드 + 입출력모드 // 읽는것인데 텍스트 파일이다. 라고하면 'rt'로 작성

@모듈화
다른 파일에서 정의된 것을 사용하기 위해서는 extern을 사용해야함
ex) 소스1 파일의 변수를 소스 파일에서 사용
(소스1 파일코드)
int ppp = 3;
(소스 파일코드)
#include <stdio.h>
extern int ppp;	// 사용안하면 ppp사용불가
void main() {
	printf("%d", ppp);	
}
extern으로 사용한 변수는 어느 파일에 어떤 것이 선언되었는지 모르기 때문에 조심해야함. 
파일 개수가 많으면 값을 찾아가기가 힘듦 그래서 만든 것이 헤더파일
헤더파일에 변수를 선언해서, 헤더파일을 include해 사용한다.

변수 한두개면 extern, 변수가 많아지면 헤더파일이 편함


@헤더파일
자기가 만든 라이브러리는 " "로
기존에 있던것은 <>
헤더파일은 구조체와 마찬가지로 변수와 함수의 원형만 선언할 수 있음(즉, 초기화는 헤더파일과 동일한 이름의 c파일에서 해야함)


@자바
자바에서 가장 중요한 개념은 싱글톤 개념
싱글톤은 객체를 하나만 생성하는 것 static을 사용해 하나만 만들어 다 공유함

***자바의 static은 전역변수로 만들어주지만 C에서의 static은 자기 파일 내에서만 사용할 수 있게 된다.
자바의 static은 메모리에 올리지만 C는 접근을 못하게함

