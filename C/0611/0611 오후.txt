@함수 포인터 
함수의 주소를 복사한 것.
선언 법 : 리턴타입 (*변수명)(매개변수의 자료형) = 함수명
호출 : 변수명() 을 사용하면 선언할 때 넣어준 함수의 내용이 실행된다.
자료형, 매개변수 : 매개변수는 넣을 함수 매개변수의 자료형만 사용해준다, 자료형은 리턴타입을 똑같이 작성한다.
ex) void  A(int a, int b); void (*arr)(int, int) = A; 
int B(); int (*arr1)(); = B; 

사용이유는 변수처럼 사용해서 코드의 변경을 쉽게 하기 위함 선언만 바꿔주면 선언한 이름으로 내용을 바꿔서 사용할 수 있기
때문. 구조체 typedef가 있다. 

함수형 포인터 배열로 선언법 :  자료형(*변수명[사이즈])(매개변수) = {넣을 함수, 함수, 함수};
이걸 사용해 입력한 값에 의한 함수호출, 반복에 의한 함수호출 가능


@void형 포인터
void형다.즉 타입이 없다는 말이다. 그래서 안의 주소를 저장할 순 있지만 직접 참조할 수 없음(자료형이 없어서 가져올 수 없음)
참조하기 위해선 저장한 타입의 포인터형으로 형변환 해줘야함.
담을 땐 다 담을 수 있다. 하지만 값을 사용하기 위해선 알맞는 것으로 바꿔서 사용해야함.
void형 포인터변수는 안에 주소를 저장할건데 뭔지 모르겠다. 라는 의미 따라서 type casting 해줘야함

문자열을 넘겨주는 것은 값을 넘겨주는 것과 같음
ex) char* a = "dlfma", char *n, n=a,  a="qerwrqwer"를 하면 a의 값만 바뀜, n은 안바뀜

@버퍼
모든 통신프로그램에 반드시 들어가야함.
없으면 무제한 대기를 해야함.
버퍼가 있기 때문에 작업을 버퍼에 던져놓고 할일할 수 있음
fflush


@tcp/ udp
udp는 게임이나 영상 스트리밍에서 사용.영상에서는 빨리 재생되는게 필요. 픽셀하나 깨지는 것은 ㄱㅊ

@strcmp
매개변수로 받은 문자를 비교해서 같으면 0, 0이 아니면 다른것

@구조체 
변수를 묶어주는 역할, 함수는 제외된다.
struct 구조체명 {
	변수만선언 초기화 하지말것
}(별명 적기가능);
별명 적는 곳에 이름을 적으면 메인에서 선언을 하지않아도 사용가능, 배열로도 가능 

구조체를 포인터로 선언하게 되면
(*구조체 포인터 변수명).내부변수로 사용하거나
구조체 포인터 변수명 -> 내부변수 이렇게 접근 가능
ex) struct ST *p;
p->내부변수 == (*p) .내부변수 

@@클래스, 구조체 차이
클래스는 변수와 메소드의 집합
구조체는 변수의 집합 , 따라서 다름

@@배열과 구조체 차이
둘 다 포인터
배열은 같은 자료형을 모아놓은것
구조체는 다른 자료형도 모을 수 있는 것

@링크드리스트
배열은 같은자료형의 연속된 주소값을 가짐, 크기도 정해야한다.
하지만 리스트는 크기에제한이 없다

삽입삭제가 용이하다, 사이즈가 무제한(메모리 사이즈까지), 데이터 찾기가 느리다. 
만약 중간에 주소가 잘못되면 그 뒤에 값들이 사라진다.
struct List {
	int data;
	struct List* next;
};

void main() {
	struct List mA, mB, mC;
	mA.data = 1;
	mA.next = &mB;
	mB.data = 3;
	mB.next = &mC;
	mC.data = 5;
	struct List* mNext;
	mNext = mA.next;
	mNext = mB.next;
	printf("%d", mNext->data); // == (*mNext).data, 화살표로 *과 . 생략가능
}
