@포인터
주소를 통해 값을 찾아오는 연산
포인터 변수는 주소값이 들어가기 때문에 빌드하는 비트에 따라 달라질 수 있다.
32비트에서 빌드시 4바이트, 64비트 빌드 시 8바이트로 바뀜
앞에 자료형이 다르다고해서 주소의 사이즈가 달라지는 것은 아님(즉, int*와 double*의 사이즈는 같다.)

char* arr[10]은 String arr[10]과 동일하게 생각하면 됨

포인터에 0을 넣으면 자동으로 널값이 들어간다
포인터로 문자열을 받으면 인덱스로 접근하여 값을 바꿀 수 없음( 포인터로 선언 시 안의 데이터를 변경할 수 없음)

const int* p = &a	//포인터 변수 p를 변수로 만듦, 포인터 변수에 접근을 못함, 출력만 가능
*p = 30;
a= 30;

int* const p = &a; // 포인터 변수에 접근 가능, 하지만 p의 값을 변경할 수 없음, 즉, p안의 주소값을 바꾸는 것이 불가
*p = 30;
p =  

@배열
선언시 char* ar[10] = {"",}라고 하면 1번 인덱스부터 끝까지 초기화가 된다.
2차원 배열은 포인터로 찾으려고 하지말고 반드시 인덱스 한 번 거쳐서 갈 것

int a[3][2] = { 1,2,3,4,5,6 };로 

@스레드
C에는 스레드 개념이 없다, 프로그램 동시에 돌리기 위해서 같이 돌려야한다.
값을 공유하기 위해선 포인터를 사용해 같은 주소로 접근해서 값을 공유한다.


@함수포인터
함수는 메모리의 주소가 있다. 선언한 함수를 포인터로 부를 수 있음
ex)
int A() {}를 int(*A)(); 로 부를 수 있음 : 함수의 타입은 리턴타입으로 결정됨.
printf("%d", A) :  함수의 주소가 출력
함수에 매개변수가 있으면 함수포인터로 호출 시 매개변수에는 함수 원형 매개변수의 데이터 타입만 작성해줌

@@void 포인터
void main() {
	int value =10;
	void* a = &value;
	double dvalue =1.1;
	void* b = &dvalue;
	printf("%d", *a) // Error(자료형이 없어서 못찾아감)
}
void 포인터는 형이 없기 때문에 어떤 값의 주소든 들어갈 수 있음. 하지만 값을 가져올 순 없음 주소만 저장가능
사용하기 위해선 typecasting해줘야함 type은 사용할 자료형의 포인트 형으로 해준다.
a를 사용하기 위해선 *(int*)a 로 사용, 
그래서 void형 포인터 변수를 배열로 사용하여 모든 자료의 주소를 다 넣어놓고 필요한 것을 형변환해서 사용하면됨
하지만 배열로 사용할 시 넣은 값과 맞는 형의 포인터 변수로 형변환 해줘야 함
ex)
int v = 10;
double dv = 1.1;
void* a[10];
a[0] = &v;
a[1] = &dv;
printf("%f", *(int*)a[1]);

a[1]은 (double*)로만 해야한다.

 
