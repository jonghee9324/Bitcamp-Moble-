@call by value : 값에 의한 참조

@call by reference : 주소에 의한 참조
포인터 : 주소
메모리 : 데이터 저장공간 (주소가 존재), 주소와 값이 공존함
값에 주소가 있으면 2중포인터
L =[0] - L에는 L[0]의 주소가 들어가 있고, L[0]에 0이 들어가 있다.
v = 0 

@class
변수+메소드의 집합, 메모리에 올라가 있지 않다, 변수와 메소드가 선언만 됨.
클래스 메소드 안에는 생성자와, 파괴자(소멸자)가 존재한다.
객체 : 메모리에 올라간 클래스
사용법(정의)
class A:
	A=1
	def AB() :
		print("")
class B: 로만 끝나면 에러, 빈클래스를 만들 땐 내부에 pass라고 적어줘야함
초기자와 소멸자가 있음

선언은 t =생성자() : t는 객체명, 생성자는 클래스명
.(점) 을 사용하는 건 다 클래스이고, 참조형이다.

클래스 내부에서 일반적으로 사용하는 기능(연산, 구문) 사용 불가
클래스의 메소드 내부에서는 사용 가능, 그래서 메소드를 기능이라 부름
자바, c의 경우 메인함수 안에서 기능을 사용, 파이썬은 알아서 해주기 때문에 되는 것 처럼 보이는 것이지만
원래는 안됨

@@ 변수
객체 = 인스턴스
파이썬에서는 인스턴스 변수를 self라고 함
일반적으로 객체로 만들어 객체명.메소드() 할 때 객체명을 인스턴스라고함
클래스 내부에서 선언된 변수는 클래스 변수
하지만 자바는 대부분 클래스 변수로 만들어도 인스턴스 변수로 만들어 사용됨
클래스 변수로 사용하려면 static으로 됨

@@@self
클래스 내부 메소드의 매개변수에는 self가 들어감 (매겨변수의 self는 인수를 전달하지 않아도된다.)
self가 사용되는 이유는 파이썬 클래스내부함수에서는 클래스에서 생성한 변수를 사용할 수 없음
사용하기 위해선, 반환값을 받던가, 글로벌을 사용해서 해야한다.
하지만 위 과정이 번거롭기 때문에 self를 사용해주는데 self는 인스턴스 변수이다.

인스턴스변수란? 클래스 내부메소드에서도 클래스안에서 선언한 변수를 사용할 수 있다?  

@@@클래스변수, 인스턴스 변수의 차이
인스턴스 변수는 객체가 살아 있을 때만 존재, 클래스 내부에 선언된 변수로 항상 존재
클래스 변수는 전역변수와 같은 느낌이고, 인스턴스변수는 지역변수의 느낌
하지만 클래스 변수는 아무리 클래스 내부함수여도 사용할 수 없다. 사용하기 위해서는 인스턴스변수화
시켜야함.
클래스 변수는 클래스 객체를 만들면 자동으로 만들어지고, 인스턴스 변수는 실행시키지 않으면 생성 x
인스턴스변수는 객체가 사라지면 같이 사라지지만, 클래스변수는 사라지지 않는다.
인스턴스 변수는 휘발성, 클래스 변수는 비휘발성
인스턴스 변수는 객체마다 다를 수 있지만, 클래스 변수는 객체마다 같음
(단, 클래스 변수를 객체마다 변경하지 않아야함)



@@초기자(이니셜라이저)는 자바의 생성자(컨스트럭트)
메모리에 올라가는 시점에 실행, 클래스 이름과 동일한 함수를 생성자라고 한다.
정의 : def __init__ :
생성자는 메소드이다. 그렇기 때문에 자바 


@@ 소멸자는 자바에 없음,C++에 소멸자 개념은 있음
메모리에서 사라지는 시점에 실행

@@다형성
다양한 형태로 사용할 수 있다. 같은 틀에서 나온 다른 객체는 다형성

@@오버로딩
같은 이름의 함수가 매개변수가 달라 하는 기능이 다른 것 



@참조형 :  call by reference
주소를 갖는 변수
배열, 리스트, 클래스 등등

@자료형
일반적으로 사용하는 int, char형 변수, 일반 자료형이 아닌 것은 모두 참조형
int, char, float, short, double, 등등

